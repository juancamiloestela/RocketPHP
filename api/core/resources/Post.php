<?php 
/**
 * This class has been autogenerated by RocketPHP
 */

namespace Resources;

class Post extends \Rocket\Api\Resource{

	protected $fields = array("title","body","blog","tags","created","updated");
	protected static $notExposed = array("");

	function receive_title($value, &$errors) {
		$errors = array_merge($errors, $this->validate_title($value));
		return $value;
	}

	function validate_title($value) {
		$errors = array();
		if (!is_string($value)){ $errors[] = "Post.title.incorrectType.string"; }
		if (strlen($value) > 30){ $errors[] = "Post.title.tooLong"; }
		if (strlen($value) < 3){ $errors[] = "Post.title.tooShort"; }
		return $errors;
	}

	function receive_body($value, &$errors) {
		$errors = array_merge($errors, $this->validate_body($value));
		return $value;
	}

	function validate_body($value) {
		$errors = array();
		if (!is_string($value)){ $errors[] = "Post.body.incorrectType.string"; }
		if (strlen($value) > 1000){ $errors[] = "Post.body.tooLong"; }
		return $errors;
	}

	function receive_blog($value, &$errors) {
		$errors = array_merge($errors, $this->validate_blog($value));
		return $value;
	}

	function validate_blog($value) {
		$errors = array();
		return $errors;
	}

	function blog($id) {
		// TODO: return query here so that users can customize result eg. LIMIT, ORDER BY, WHERE x, etc
		$query = "SELECT * FROM Blog WHERE id = :id";
		$statement = $this->db->prepare($query);
		$statement->execute(array('id' => $id));
		$data = $statement->fetch(\PDO::FETCH_ASSOC);
		
		// TODO: $data = customHook($data);
		return $data;
	}

	function receive_tags($value, &$errors) {
		$errors = array_merge($errors, $this->validate_tags($value));
		return $value;
	}

	function validate_tags($value) {
		$errors = array();
		return $errors;
	}

	function tags($id) {
		// TODO: return query here so that users can customize result eg. LIMIT, ORDER BY, WHERE x, etc
		$query = "SELECT Tag.* FROM Tag JOIN posts_tags ON Tag.id = posts_tags.tags_id WHERE posts_tags.posts_id = :id";
		$statement = $this->db->prepare($query);
		$statement->execute(array('id' => $id));
		$data = $statement->fetchAll(\PDO::FETCH_ASSOC);
		
		// TODO: $data = customHook($data);
		return $data;
	}

	function receive_created($value, &$errors) {
		$errors = array_merge($errors, $this->validate_created($value));
		return $value;
	}

	function validate_created($value) {
		$errors = array();
		if (!is_date($value, 'Y-m-d H:i:s')){ $errors[] = "Post.created.incorrectType.datetime"; }
		return $errors;
	}

	function receive_updated($value, &$errors) {
		$errors = array_merge($errors, $this->validate_updated($value));
		return $value;
	}

	function validate_updated($value) {
		$errors = array();
		if (!is_date($value, 'Y-m-d H:i:s')){ $errors[] = "Post.updated.incorrectType.datetime"; }
		return $errors;
	}

	function GET_posts_when_public($data) {
		$errors = array();

		\Rocket::call(array("ResponseTime", "on_start"), $data);
		if (count($errors)) {
			throw new \InvalidInputDataException($errors);
		}

		\Rocket::call(array("TimeTracked", "on_input"), $data);
		\Rocket::call(array("paginated", "on_input"), $data);
		$query = "SELECT * FROM Post";
		\Rocket::call(array("paginated", "on_query"), $query, $data);
		$statement = $this->db->prepare($query);
		$statement->execute( $this->getDataForQuery($query, $data) );
		$data = $statement->fetchAll(\PDO::FETCH_OBJ);
		\Rocket::call(array("ResponseTime", "on_data"), $data);
		\Rocket::call(array("paginated", "on_data"), $data);
		return $data;
	}

	function POST_posts_when_public($data) {
		$errors = array();

		\Rocket::call(array("ResponseTime", "on_start"), $data);
		if (count($errors)) {
			throw new \InvalidInputDataException($errors);
		}

		\Rocket::call(array("TimeTracked", "on_input"), $data);
		$fields = array_intersect($this->fields, array_keys((array)$data));
		$query = "INSERT INTO Post (".implode(',', $fields).") VALUES (:".implode(', :', $fields).")";
		$statement = $this->db->prepare($query);
		$statement->execute( $this->getDataForQuery($query, $data) );
		$id = $this->db->lastInsertId();
		if (!$id){
			throw new \Exception('Could not create resource');
		}
		$data = array("created" => $id);
		\Rocket::call(array("ResponseTime", "on_data"), $data);
		return $data;
	}

	function GET_posts_id_when_public($data, $id) {
		$errors = array();

		$data->id = $id;

		\Rocket::call(array("ResponseTime", "on_start"), $data);
		if (count($errors)) {
			throw new \InvalidInputDataException($errors);
		}

		\Rocket::call(array("TimeTracked", "on_input"), $data);
		$query = "SELECT * FROM Post WHERE id = :id LIMIT 1";
		$statement = $this->db->prepare($query);
		$statement->execute( $this->getDataForQuery($query, $data) );
		$data = $statement->fetch(\PDO::FETCH_OBJ);
		if (!$data){
			throw new \NotFoundException();
		}
		\Rocket::call(array("ResponseTime", "on_data"), $data);
		return $data;
	}

	function PUT_posts_id_when_public($data, $id) {
		$errors = array();

		$data->id = $id;

		\Rocket::call(array("ResponseTime", "on_start"), $data);
		if (count($errors)) {
			throw new \InvalidInputDataException($errors);
		}

		\Rocket::call(array("TimeTracked", "on_input"), $data);
		$fields = array_intersect($this->fields, array_keys((array)$data));
		$pairs = array();
		foreach ($fields as $field){
			$pairs[] = $field . " = :" . $field;
		}
		$query = "UPDATE Post SET ".implode(', ', $pairs)." WHERE id = :id";
		$statement = $this->db->prepare($query);
		$result = $statement->execute( $this->getDataForQuery($query, $data) );
		if ($statement->rowCount() == 0){
			throw new \NotFoundException();
		}
		if (!$result){
			throw new \Exception('Could not update resource');
		}
		$data = array("updated" => $id);
		\Rocket::call(array("ResponseTime", "on_data"), $data);
		return $data;
	}

	function GET_posts_id_blog_when_public($data, $id) {
		$errors = array();

		$data->id = $id;

		\Rocket::call(array("ResponseTime", "on_start"), $data);
		if (count($errors)) {
			throw new \InvalidInputDataException($errors);
		}

		\Rocket::call(array("TimeTracked", "on_input"), $data);
		$query = "SELECT * FROM Post WHERE id = :id LIMIT 1";
		$statement = $this->db->prepare($query);
		$statement->execute( $this->getDataForQuery($query, $data) );
		$data = $statement->fetch(\PDO::FETCH_OBJ);
		if (!$data){
			throw new \NotFoundException();
		}
		\Rocket::call(array("ResponseTime", "on_data"), $data);
		return $data;
	}

	function GET_posts_id_tags_when_public($data, $id) {
		$errors = array();

		$data->id = $id;

		\Rocket::call(array("ResponseTime", "on_start"), $data);
		if (count($errors)) {
			throw new \InvalidInputDataException($errors);
		}

		\Rocket::call(array("TimeTracked", "on_input"), $data);
		$data = $this->tags($id);
		\Rocket::call(array("ResponseTime", "on_data"), $data);
		return $data;
	}

	function GET_posts_tagged_tag_when_public($data, $tag) {
		$errors = array();

		$data->tag = $tag;

		\Rocket::call(array("ResponseTime", "on_start"), $data);
		if (count($errors)) {
			throw new \InvalidInputDataException($errors);
		}

		\Rocket::call(array("TimeTracked", "on_input"), $data);
		$query = "SELECT * FROM Post WHERE id = :id LIMIT 1";
		\Rocket::call(array("Tags", "on_query"), $query, $data);
		$statement = $this->db->prepare($query);
		$statement->execute( $this->getDataForQuery($query, $data) );
		$data = $statement->fetch(\PDO::FETCH_OBJ);
		if (!$data){
			throw new \NotFoundException();
		}
		\Rocket::call(array("ResponseTime", "on_data"), $data);
		return $data;
	}

}